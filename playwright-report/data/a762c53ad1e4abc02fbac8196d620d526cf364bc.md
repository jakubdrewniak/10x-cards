# Test info

- Name: Generate Flashcards Page >> should generate and save flashcards
- Location: /home/kuba/code/10x-cards3/e2e/generate-flashcards.spec.ts:19:3

# Error details

```
Error: locator.click: Test timeout of 60000ms exceeded.
Call log:
  - waiting for getByTestId('generate-flashcards-button')

    at GenerateFlashcardsPage.generateFlashcards (/home/kuba/code/10x-cards3/e2e/page-objects/generate-flashcards.page.ts:148:31)
    at /home/kuba/code/10x-cards3/e2e/generate-flashcards.spec.ts:50:18
```

# Page snapshot

```yaml
- link "10x Cards":
  - /url: /
- link "Zaloguj siÄ™":
  - /url: /login
- main:
  - main:
    - heading "Generate Flashcards" [level=1]
    - textbox "Paste your text here (1,000 - 10,000 characters)": React Hooks Documentation useState is a Hook that lets you add React state to function components. useEffect is a Hook that lets you perform side effects in function components. useContext is a Hook that lets you subscribe to React context without introducing nesting. useReducer is a Hook that lets you manage local state of complex components with a reducer. useCallback is a Hook that lets you prevent unnecessary re-renders by memoizing functions. useMemo is similar to useCallback but for memoizing values instead of functions. useRef is a Hook that lets you create a mutable reference that persists across re-renders. useImperativeHandle is a Hook that lets you customize the instance value exposed to parent components. useLayoutEffect is similar to useEffect but fires synchronously after all DOM mutations. useDebugValue is a Hook that lets you add a label to custom hooks in React DevTools. React Hooks Documentation useState is a Hook that lets you add React state to function components. useEffect is a Hook that lets you perform side effects in function components. useContext is a Hook that lets you subscribe to React context without introducing nesting. useReducer is a Hook that lets you manage local state of complex components with a reducer. useCallback is a Hook that lets you prevent unnecessary re-renders by memoizing functions. useMemo is similar to useCallback but for memoizing values instead of functions. useRef is a Hook that lets you create a mutable reference that persists across re-renders. useImperativeHandle is a Hook that lets you customize the instance value exposed to parent components. useLayoutEffect is similar to useEffect but fires synchronously after all DOM mutations. useDebugValue is a Hook that lets you add a label to custom hooks in React DevTools.
    - text: 2,084 / 10,000 characters
    - button "Generate Flashcards"
- region "Notifications alt+T"
```

# Test source

```ts
   48 |     return this.page.getByTestId(`save-edit-${this.index}`);
   49 |   }
   50 |
   51 |   private get cancelEditButton(): Locator {
   52 |     return this.page.getByTestId(`cancel-edit-${this.index}`);
   53 |   }
   54 |
   55 |   async getFront(): Promise<string> {
   56 |     return await this.frontText.textContent() || '';
   57 |   }
   58 |
   59 |   async getBack(): Promise<string> {
   60 |     return await this.backText.textContent() || '';
   61 |   }
   62 |
   63 |   async getStatus(): Promise<string> {
   64 |     return await this.statusElement.textContent() || '';
   65 |   }
   66 |
   67 |   async accept(): Promise<void> {
   68 |     await this.acceptButton.click();
   69 |   }
   70 |
   71 |   async reject(): Promise<void> {
   72 |     await this.rejectButton.click();
   73 |   }
   74 |
   75 |   async edit(front: string, back: string): Promise<void> {
   76 |     await this.editButton.click();
   77 |     await this.frontInput.fill(front);
   78 |     await this.backInput.fill(back);
   79 |     await this.saveEditButton.click();
   80 |   }
   81 |
   82 |   async cancelEdit(): Promise<void> {
   83 |     await this.cancelEditButton.click();
   84 |   }
   85 | }
   86 |
   87 | /**
   88 |  * Page Object Model for the Generate Flashcards page
   89 |  * Represents the page where users can generate, review and save flashcards
   90 |  */
   91 | export class GenerateFlashcardsPage {
   92 |   readonly page: Page;
   93 |
   94 |   constructor(page: Page) {
   95 |     this.page = page;
   96 |   }
   97 |
   98 |   // Input section
   99 |   private get inputTextArea(): Locator {
  100 |     return this.page.getByTestId('generate-input-text');
  101 |   }
  102 |
  103 |   private get generateButton(): Locator {
  104 |     return this.page.getByTestId('generate-flashcards-button');
  105 |   }
  106 |
  107 |   // Loading state
  108 |   private get loadingIndicator(): Locator {
  109 |     return this.page.getByTestId('loading-indicator');
  110 |   }
  111 |
  112 |   // Flashcards management
  113 |   private get acceptAllButton(): Locator {
  114 |     return this.page.getByTestId('accept-all-flashcards-button');
  115 |   }
  116 |
  117 |   private get saveButton(): Locator {
  118 |     return this.page.getByTestId('save-flashcards-button');
  119 |   }
  120 |
  121 |   private get flashcardsList(): Locator {
  122 |     return this.page.getByRole('list');
  123 |   }
  124 |
  125 |   /**
  126 |    * Navigate to the generate flashcards page
  127 |    */
  128 |   async goto() {
  129 |     await this.page.goto('/generate');
  130 |     // Wait for the main input area to be ready
  131 |     await this.inputTextArea.waitFor({ state: 'visible' });
  132 |   }
  133 |
  134 |   /**
  135 |    * Enter text into the input area
  136 |    */
  137 |   async enterText(text: string) {
  138 |     // Wait for the input area to be ready and enabled
  139 |     await this.inputTextArea.waitFor({ state: 'visible' });
  140 |     await expect(this.inputTextArea).toBeEnabled();
  141 |     await this.inputTextArea.fill(text);
  142 |   }
  143 |
  144 |   /**
  145 |    * Click generate button and wait for results
  146 |    */
  147 |   async generateFlashcards() {
> 148 |     await this.generateButton.click();
      |                               ^ Error: locator.click: Test timeout of 60000ms exceeded.
  149 |     await this.waitForGeneration();
  150 |   }
  151 |
  152 |   /**
  153 |    * Wait for the generation process to complete
  154 |    */
  155 |   private async waitForGeneration() {
  156 |     // Wait for loading indicator to appear
  157 |     await this.loadingIndicator.waitFor({ state: 'visible' });
  158 |     // Wait for loading indicator to disappear
  159 |     await this.loadingIndicator.waitFor({ state: 'hidden' });
  160 |     // Wait for flashcards list to be visible
  161 |     await this.flashcardsList.waitFor({ state: 'visible' });
  162 |   }
  163 |
  164 |   /**
  165 |    * Accept all generated flashcards
  166 |    */
  167 |   async acceptAllFlashcards() {
  168 |     await this.acceptAllButton.click();
  169 |   }
  170 |
  171 |   /**
  172 |    * Save or copy flashcards based on login state
  173 |    */
  174 |   async saveFlashcards() {
  175 |     await this.saveButton.click();
  176 |   }
  177 |
  178 |   /**
  179 |    * Check if success toast is visible
  180 |    */
  181 |   async checkSuccessToast() {
  182 |     // Wait for toast with success message
  183 |     await this.page.getByText(/Successfully (saved|copied)/).waitFor({ state: 'visible' });
  184 |   }
  185 |
  186 |   /**
  187 |    * Get individual flashcard by index
  188 |    */
  189 |   getFlashcard(index: number) {
  190 |     return new FlashcardItem(this.page, index);
  191 |   }
  192 | } 
```